# Техническая документация системы автоматизации управления контентом

## Содержание

1. [Архитектура системы](#архитектура-системы)
2. [Компоненты системы](#компоненты-системы)
3. [Структура проекта](#структура-проекта)
4. [Модуль парсинга новостей](#модуль-парсинга-новостей)
5. [Модуль рерайта контента](#модуль-рерайта-контента)
6. [Модуль автопостинга](#модуль-автопостинга)
7. [Интеграция компонентов](#интеграция-компонентов)
8. [API системы](#api-системы)
9. [Безопасность](#безопасность)
10. [Масштабирование](#масштабирование)

## Архитектура системы

Система автоматизации управления контентом построена на основе модульной архитектуры, состоящей из трех основных компонентов:

1. **Модуль парсинга новостей** - отвечает за сбор актуальных новостей из различных источников.
2. **Модуль рерайта контента** - преобразует собранные новости в уникальный контент с учетом tone of voice.
3. **Модуль автопостинга** - публикует подготовленный контент в социальных сетях.

Система использует комбинацию PHP и Python для обеспечения максимальной гибкости и эффективности:
- PHP используется для основной логики приложения, веб-интерфейса и интеграции компонентов
- Python используется для парсинга новостей и автоматизации взаимодействия с браузером

## Компоненты системы

### Основные компоненты

- **Core** - ядро системы, содержащее базовые классы и интерфейсы
- **Parsers** - компоненты для парсинга новостей из различных источников
- **Rewrite** - компоненты для рерайта контента
- **Posting** - компоненты для публикации контента в социальных сетях
- **Controllers** - контроллеры для веб-интерфейса
- **Application** - основной класс приложения

### Вспомогательные компоненты

- **Config** - компоненты для работы с конфигурацией
- **Logs** - компоненты для логирования
- **Utils** - утилиты и вспомогательные функции

## Структура проекта

```
social_media_automation/
├── config/                  # Конфигурационные файлы
│   ├── .env.example         # Пример файла окружения
│   ├── sources.php          # Конфигурация источников новостей
│   └── tone_of_voice.php    # Конфигурация шаблонов tone of voice
├── docs/                    # Документация
│   ├── deployment.md        # Руководство по развертыванию
│   ├── technical.md         # Техническая документация
│   └── user_manual.md       # Руководство пользователя
├── logs/                    # Директория для логов
├── public/                  # Публичная директория
│   ├── css/                 # CSS файлы
│   ├── js/                  # JavaScript файлы
│   ├── img/                 # Изображения
│   └── index.php            # Точка входа для веб-интерфейса
├── src/                     # Исходный код
│   ├── Application.php      # Основной класс приложения
│   ├── Controllers/         # Контроллеры
│   ├── Core/                # Ядро системы
│   │   ├── Config.php       # Класс для работы с конфигурацией
│   │   ├── LogManager.php   # Класс для логирования
│   │   └── AutomationWorkflow.php # Класс для интеграции компонентов
│   ├── Parsers/             # Компоненты для парсинга новостей
│   │   ├── NewsParserInterface.php
│   │   ├── AbstractNewsParser.php
│   │   ├── Source1NewsParser.php
│   │   └── NewsParserManager.php
│   ├── parsers/             # Python-скрипты для парсинга
│   │   ├── news_parser.py
│   │   └── selenium_parser.py
│   ├── Rewrite/             # Компоненты для рерайта контента
│   │   ├── ContentRewriterInterface.php
│   │   ├── AbstractContentRewriter.php
│   │   ├── MakeOpenAIRewriter.php
│   │   └── ContentRewriteManager.php
│   └── Posting/             # Компоненты для публикации контента
│       ├── SocialMediaPosterInterface.php
│       ├── AbstractSocialMediaPoster.php
│       ├── TwitterPoster.php
│       ├── LinkedInPoster.php
│       ├── ThreadsPoster.php
│       ├── YouTubePoster.php
│       └── SocialMediaPostingManager.php
├── tests/                   # Тесты
│   └── run_tests.py         # Скрипт для запуска тестов
├── vendor/                  # Зависимости PHP (Composer)
├── composer.json            # Конфигурация Composer
└── cli.php                  # Точка входа для CLI
```

## Модуль парсинга новостей

### Архитектура модуля

Модуль парсинга новостей состоит из PHP-классов для управления парсерами и Python-скриптов для непосредственного парсинга:

- `NewsParserInterface` - интерфейс для всех парсеров
- `AbstractNewsParser` - абстрактный класс, реализующий общую логику парсеров
- `Source1NewsParser` - конкретная реализация парсера для определенного источника
- `NewsParserManager` - класс для управления парсерами

### Принцип работы

1. `NewsParserManager` получает список источников из конфигурации
2. Для каждого источника создается соответствующий парсер
3. Парсер извлекает новости из источника
4. Новости фильтруются по ключевым словам
5. Результаты сохраняются для дальнейшей обработки

### Python-парсеры

Для парсинга используются Python-скрипты:

- `news_parser.py` - базовый класс для парсинга с использованием BeautifulSoup
- `selenium_parser.py` - класс для парсинга с использованием Selenium (для динамических сайтов)

## Модуль рерайта контента

### Архитектура модуля

Модуль рерайта контента состоит из следующих компонентов:

- `ContentRewriterInterface` - интерфейс для всех рерайтеров
- `AbstractContentRewriter` - абстрактный класс, реализующий общую логику рерайтеров
- `MakeOpenAIRewriter` - реализация рерайтера с использованием Make.com и OpenAI
- `ContentRewriteManager` - класс для управления рерайтерами

### Принцип работы

1. `ContentRewriteManager` получает новость для рерайта
2. На основе целевого аккаунта выбирается соответствующий шаблон tone of voice
3. Рерайтер преобразует текст новости в соответствии с шаблоном
4. Результат возвращается для дальнейшей публикации

### Интеграция с Make.com и OpenAI

Для рерайта используется интеграция с Make.com, которая в свою очередь использует API OpenAI:

1. Система отправляет запрос на Make.com с текстом новости и промптом
2. Make.com формирует запрос к OpenAI API
3. OpenAI генерирует новый текст
4. Make.com возвращает результат в систему

## Модуль автопостинга

### Архитектура модуля

Модуль автопостинга состоит из следующих компонентов:

- `SocialMediaPosterInterface` - интерфейс для всех постеров
- `AbstractSocialMediaPoster` - абстрактный класс, реализующий общую логику постеров
- `TwitterPoster`, `LinkedInPoster`, `ThreadsPoster`, `YouTubePoster` - реализации постеров для конкретных социальных сетей
- `SocialMediaPostingManager` - класс для управления постерами

### Принцип работы

1. `SocialMediaPostingManager` получает контент для публикации
2. На основе целевого аккаунта выбирается соответствующий постер
3. Постер публикует контент в социальной сети
4. Результат публикации сохраняется в системе

### Особенности реализации для разных социальных сетей

#### Twitter

- Использует официальный API Twitter
- Поддерживает публикацию текста и медиа
- Учитывает ограничение на длину текста (280 символов)

#### LinkedIn

- Использует официальный API LinkedIn
- Поддерживает публикацию текста, ссылок и медиа
- Учитывает особенности форматирования LinkedIn

#### YouTube

- Использует YouTube API для публикации в сообществе
- Поддерживает публикацию текста и ссылок

#### Threads

- Использует Dolphin Anty для эмуляции поведения человека
- Поддерживает публикацию текста и медиа
- Учитывает антифрод-защиту Threads

## Интеграция компонентов

### Класс AutomationWorkflow

Класс `AutomationWorkflow` отвечает за интеграцию всех компонентов системы:

```php
class AutomationWorkflow
{
    private $parserManager;
    private $rewriteManager;
    private $postingManager;
    private $logger;
    
    public function __construct(
        NewsParserManager $parserManager,
        ContentRewriteManager $rewriteManager,
        SocialMediaPostingManager $postingManager,
        LogManager $logger
    ) {
        $this->parserManager = $parserManager;
        $this->rewriteManager = $rewriteManager;
        $this->postingManager = $postingManager;
        $this->logger = $logger;
    }
    
    public function run(array $keywords = [], array $options = []): array
    {
        // 1. Парсинг новостей
        $news = $this->parserManager->parseNews($keywords);
        
        // 2. Рерайт контента
        $rewrittenContent = [];
        foreach ($news as $item) {
            foreach ($options['accounts'] as $account) {
                $rewrittenContent[] = [
                    'news' => $item,
                    'account' => $account,
                    'content' => $this->rewriteManager->rewrite($item['content'], [
                        'tone_of_voice' => $account['tone_of_voice']
                    ])
                ];
            }
        }
        
        // 3. Публикация контента
        $results = [];
        foreach ($rewrittenContent as $item) {
            $results[] = [
                'news' => $item['news'],
                'account' => $item['account'],
                'content' => $item['content'],
                'result' => $this->postingManager->post(
                    $item['account']['id'],
                    $item['content'],
                    $item['news']['media'] ?? []
                )
            ];
        }
        
        // 4. Формирование отчета
        return $this->generateReport($news, $rewrittenContent, $results);
    }
    
    private function generateReport(array $news, array $rewrittenContent, array $results): array
    {
        // Логика формирования отчета
    }
    
    public function checkSystemStatus(): array
    {
        // Проверка статуса всех компонентов системы
    }
}
```

### Процесс автоматизации

1. Пользователь запускает процесс автоматизации через веб-интерфейс или CLI
2. Создается экземпляр `AutomationWorkflow`
3. Вызывается метод `run()` с параметрами (ключевые слова, аккаунты и т.д.)
4. `AutomationWorkflow` последовательно вызывает методы парсинга, рерайта и публикации
5. Результаты сохраняются и отображаются пользователю

## API системы

### REST API

Система предоставляет REST API для интеграции с другими системами:

#### Endpoints

- `GET /api/status` - получение статуса системы
- `GET /api/news` - получение списка новостей
- `GET /api/posts` - получение списка публикаций
- `POST /api/automation/run` - запуск процесса автоматизации
- `GET /api/accounts` - получение списка аккаунтов
- `GET /api/statistics` - получение статистики

#### Аутентификация

API использует токены для аутентификации:

```
Authorization: Bearer YOUR_API_TOKEN
```

#### Пример запроса

```
POST /api/automation/run
Content-Type: application/json
Authorization: Bearer YOUR_API_TOKEN

{
  "keywords": ["технологии", "AI"],
  "accounts": ["twitter_account1", "linkedin_account1"],
  "max_news": 5
}
```

## Безопасность

### Защита API ключей

API ключи хранятся в файле `.env`, который не включается в систему контроля версий. Для доступа к API ключам используется класс `Config`, который загружает значения из `.env` файла.

### Защита от CSRF

Веб-интерфейс использует CSRF-токены для защиты от CSRF-атак. Токены генерируются для каждой сессии и проверяются при каждом POST-запросе.

### Защита от XSS

Все пользовательские данные экранируются перед выводом в HTML для предотвращения XSS-атак.

### Защита от SQL-инъекций

Система использует подготовленные запросы для взаимодействия с базой данных, что предотвращает SQL-инъекции.

## Масштабирование

### Горизонтальное масштабирование

Система поддерживает горизонтальное масштабирование:

1. Парсеры могут работать на отдельных серверах
2. Рерайтеры могут работать на отдельных серверах
3. Постеры могут работать на отдельных серверах

### Очереди задач

Для обработки большого количества задач система может использовать очереди:

1. Задачи парсинга добавляются в очередь
2. Задачи рерайта добавляются в очередь
3. Задачи публикации добавляются в очередь

Это позволяет распределить нагрузку и обеспечить отказоустойчивость системы.

### Кэширование

Система использует кэширование для оптимизации производительности:

1. Кэширование результатов парсинга
2. Кэширование шаблонов tone of voice
3. Кэширование статусов аккаунтов

Это позволяет снизить нагрузку на API социальных сетей и ускорить работу системы.
